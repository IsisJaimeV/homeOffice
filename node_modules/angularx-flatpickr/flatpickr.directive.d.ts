import { ElementRef, AfterViewInit, EventEmitter, OnChanges, SimpleChanges, OnDestroy, Renderer2 } from '@angular/core';
import { FlatpickrDefaults, DisableEnableDate } from './flatpickr-defaults.service';
import { ControlValueAccessor } from '@angular/forms';
import * as ɵngcc0 from '@angular/core';
export interface FlatPickrOutputOptions {
    selectedDates: Date[];
    dateString: string;
    instance: any;
}
export interface FlatPickrDayCreateOutputOptions extends FlatPickrOutputOptions {
    dayElement: HTMLElement;
}
export declare const FLATPICKR_CONTROL_VALUE_ACCESSOR: any;
export declare class FlatpickrDirective implements AfterViewInit, OnChanges, OnDestroy, ControlValueAccessor {
    private elm;
    private defaults;
    private renderer;
    /**
     * Exactly the same as date format, but for the altInput field.
     */
    altFormat: string;
    /**
     * 	Show the user a readable date (as per altFormat), but return something totally different to the server.
     */
    altInput: boolean;
    /**
     * This class will be added to the input element created by the altInput option.
     * Note that `altInput` already inherits classes from the original input.
     */
    altInputClass: string;
    /**
     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
     */
    allowInput: boolean;
    /**
     * Instead of `body`, appends the calendar to the specified node instead.
     */
    appendTo: HTMLElement;
    /**
     * Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat. If you change this, you should choose a value that will make sense if a screen reader reads it out loud.
     */
    ariaDateFormat?: string;
    /**
     * Whether clicking on the input should open the picker.
     * You could disable this if you wish to open the calendar manually `with.open()`.
     */
    clickOpens: boolean;
    /**
     * A string of characters which are used to define how the date will be displayed in the input box.
     * The supported characters are defined in the table below.
     */
    dateFormat: string;
    /**
     * Initial value of the hour element.
     */
    defaultHour?: number;
    /**
     * Initial value of the minute element.
     */
    defaultMinute?: number;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-specific-dates">disabling dates</a>.
     */
    disable: DisableEnableDate[];
    /**
     * Set disableMobile to true to always use the non-native picker.
     * By default, Flatpickr utilizes native datetime widgets unless certain options (e.g. disable) are used.
     */
    disableMobile: boolean;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-all-dates-except-select-few">enabling dates</a>.
     */
    enable: DisableEnableDate[];
    /**
     * Enables time picker.
     */
    enableTime: boolean;
    /**
     * Enables seconds in the time picker.
     */
    enableSeconds: boolean;
    /**
     * Allows using a custom date formatting function instead of the built-in handling for date formats using dateFormat, altFormat, etc.
     */
    formatDate?: (value: any) => string;
    /**
     * Adjusts the step for the hour input (incl. scrolling).
     */
    hourIncrement: number;
    /**
     * Displays the calendar inline.
     */
    inline: boolean;
    /**
     * The maximum date that a user can pick to (inclusive).
     */
    maxDate: string | Date;
    /**
     * The minimum date that a user can start picking from (inclusive).
     */
    minDate: string | Date;
    /**
     * Adjusts the step for the minute input (incl. scrolling).
     */
    minuteIncrement: number;
    /**
     * Select a single date, multiple dates or a date range.
     */
    mode: 'single' | 'multiple' | 'range';
    /**
     * HTML for the arrow icon, used to switch months.
     */
    nextArrow: string;
    /**
     * Hides the day selection in calendar. Use it along with `enableTime` to create a time picker.
     */
    noCalendar: boolean;
    /**
     * Function that expects a date string and must return a Date object.
     */
    parseDate: (str: string) => Date;
    /**
     * HTML for the left arrow icon.
     */
    prevArrow: string;
    /**
     * Show the month using the shorthand version (ie, Sep instead of September).
     */
    shorthandCurrentMonth: boolean;
    /**
     * Position the calendar inside the wrapper and next to the input element. (Leave `false` unless you know what you're doing).
     */
    static: boolean;
    /**
     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
     */
    time24hr: boolean;
    /**
     * Enables display of week numbers in calendar.
     */
    weekNumbers: boolean;
    /**
     * You may override the function that extracts the week numbers from a Date by supplying a getWeek function.
     * It takes in a date as a parameter and should return a corresponding string that you want to appear left of every week.
     */
    getWeek: (date: Date) => string;
    /**
     * Custom elements and input groups.
     */
    wrap: boolean;
    /**
     * Array of plugin instances to use.
     */
    plugins: any[];
    /**
     * The locale object or string to use for the locale.
     */
    locale: object | string;
    /**
     * Auto convert the ngModel value from a string to a date / array of dates / from - to date object depending on the `mode`
     */
    convertModelValue: boolean;
    /**
     * Gets triggered once the calendar is in a ready state
     */
    flatpickrReady: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the user selects a date, or changes the time on a selected date.
     */
    flatpickrChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the input value is updated with a new date string.
     */
    flatpickrValueUpdate: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the calendar is opened.
     */
    flatpickrOpen: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the calendar is closed.
     */
    flatpickrClose: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the month is changed, either by the user or programmatically.
     */
    flatpickrMonthChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the year is changed, either by the user or programmatically.
     */
    flatpickrYearChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Take full control of every date cell with this output
     */
    flatpickrDayCreate: EventEmitter<FlatPickrDayCreateOutputOptions>;
    private instance;
    private isDisabled;
    private initialValue;
    onChangeFn: (value: any) => void;
    onTouchedFn: () => void;
    constructor(elm: ElementRef, defaults: FlatpickrDefaults, renderer: Renderer2);
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    writeValue(value: any): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    inputChanged(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<FlatpickrDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<FlatpickrDirective, "[mwlFlatpickr]", never, { "altFormat": "altFormat"; "altInput": "altInput"; "altInputClass": "altInputClass"; "allowInput": "allowInput"; "appendTo": "appendTo"; "ariaDateFormat": "ariaDateFormat"; "clickOpens": "clickOpens"; "dateFormat": "dateFormat"; "defaultHour": "defaultHour"; "defaultMinute": "defaultMinute"; "disable": "disable"; "disableMobile": "disableMobile"; "enable": "enable"; "enableTime": "enableTime"; "enableSeconds": "enableSeconds"; "formatDate": "formatDate"; "hourIncrement": "hourIncrement"; "inline": "inline"; "maxDate": "maxDate"; "minDate": "minDate"; "minuteIncrement": "minuteIncrement"; "mode": "mode"; "nextArrow": "nextArrow"; "noCalendar": "noCalendar"; "parseDate": "parseDate"; "prevArrow": "prevArrow"; "shorthandCurrentMonth": "shorthandCurrentMonth"; "static": "static"; "time24hr": "time24hr"; "weekNumbers": "weekNumbers"; "getWeek": "getWeek"; "wrap": "wrap"; "plugins": "plugins"; "locale": "locale"; "convertModelValue": "convertModelValue"; }, { "flatpickrReady": "flatpickrReady"; "flatpickrChange": "flatpickrChange"; "flatpickrValueUpdate": "flatpickrValueUpdate"; "flatpickrOpen": "flatpickrOpen"; "flatpickrClose": "flatpickrClose"; "flatpickrMonthChange": "flatpickrMonthChange"; "flatpickrYearChange": "flatpickrYearChange"; "flatpickrDayCreate": "flatpickrDayCreate"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdHBpY2tyLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJmbGF0cGlja3IuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBBZnRlclZpZXdJbml0LCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgT25EZXN0cm95LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZsYXRwaWNrckRlZmF1bHRzLCBEaXNhYmxlRW5hYmxlRGF0ZSB9IGZyb20gJy4vZmxhdHBpY2tyLWRlZmF1bHRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5leHBvcnQgaW50ZXJmYWNlIEZsYXRQaWNrck91dHB1dE9wdGlvbnMge1xuICAgIHNlbGVjdGVkRGF0ZXM6IERhdGVbXTtcbiAgICBkYXRlU3RyaW5nOiBzdHJpbmc7XG4gICAgaW5zdGFuY2U6IGFueTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmxhdFBpY2tyRGF5Q3JlYXRlT3V0cHV0T3B0aW9ucyBleHRlbmRzIEZsYXRQaWNrck91dHB1dE9wdGlvbnMge1xuICAgIGRheUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgRkxBVFBJQ0tSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueTtcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEZsYXRwaWNrckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgcHJpdmF0ZSBlbG07XG4gICAgcHJpdmF0ZSBkZWZhdWx0cztcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIC8qKlxuICAgICAqIEV4YWN0bHkgdGhlIHNhbWUgYXMgZGF0ZSBmb3JtYXQsIGJ1dCBmb3IgdGhlIGFsdElucHV0IGZpZWxkLlxuICAgICAqL1xuICAgIGFsdEZvcm1hdDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFx0U2hvdyB0aGUgdXNlciBhIHJlYWRhYmxlIGRhdGUgKGFzIHBlciBhbHRGb3JtYXQpLCBidXQgcmV0dXJuIHNvbWV0aGluZyB0b3RhbGx5IGRpZmZlcmVudCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIGFsdElucHV0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5wdXQgZWxlbWVudCBjcmVhdGVkIGJ5IHRoZSBhbHRJbnB1dCBvcHRpb24uXG4gICAgICogTm90ZSB0aGF0IGBhbHRJbnB1dGAgYWxyZWFkeSBpbmhlcml0cyBjbGFzc2VzIGZyb20gdGhlIG9yaWdpbmFsIGlucHV0LlxuICAgICAqL1xuICAgIGFsdElucHV0Q2xhc3M6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgYSBkYXRlIGRpcmVjdGx5IGlucHV0IHRoZSBpbnB1dCBmaWVsZC4gQnkgZGVmYXVsdCwgZGlyZWN0IGVudHJ5IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGFsbG93SW5wdXQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5zdGVhZCBvZiBgYm9keWAsIGFwcGVuZHMgdGhlIGNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgbm9kZSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFwcGVuZFRvOiBIVE1MRWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyB0aGUgZGF0ZSB3aWxsIGJlIGZvcm1hdHRlZCBpbiB0aGUgYXJpYS1sYWJlbCBmb3IgY2FsZW5kYXIgZGF5cywgdXNpbmcgdGhlIHNhbWUgdG9rZW5zIGFzIGRhdGVGb3JtYXQuIElmIHlvdSBjaGFuZ2UgdGhpcywgeW91IHNob3VsZCBjaG9vc2UgYSB2YWx1ZSB0aGF0IHdpbGwgbWFrZSBzZW5zZSBpZiBhIHNjcmVlbiByZWFkZXIgcmVhZHMgaXQgb3V0IGxvdWQuXG4gICAgICovXG4gICAgYXJpYURhdGVGb3JtYXQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBjbGlja2luZyBvbiB0aGUgaW5wdXQgc2hvdWxkIG9wZW4gdGhlIHBpY2tlci5cbiAgICAgKiBZb3UgY291bGQgZGlzYWJsZSB0aGlzIGlmIHlvdSB3aXNoIHRvIG9wZW4gdGhlIGNhbGVuZGFyIG1hbnVhbGx5IGB3aXRoLm9wZW4oKWAuXG4gICAgICovXG4gICAgY2xpY2tPcGVuczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyBvZiBjaGFyYWN0ZXJzIHdoaWNoIGFyZSB1c2VkIHRvIGRlZmluZSBob3cgdGhlIGRhdGUgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlucHV0IGJveC5cbiAgICAgKiBUaGUgc3VwcG9ydGVkIGNoYXJhY3RlcnMgYXJlIGRlZmluZWQgaW4gdGhlIHRhYmxlIGJlbG93LlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEhvdXI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgbWludXRlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZGVmYXVsdE1pbnV0ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci9leGFtcGxlcy8jZGlzYWJsaW5nLXNwZWNpZmljLWRhdGVzXCI+ZGlzYWJsaW5nIGRhdGVzPC9hPi5cbiAgICAgKi9cbiAgICBkaXNhYmxlOiBEaXNhYmxlRW5hYmxlRGF0ZVtdO1xuICAgIC8qKlxuICAgICAqIFNldCBkaXNhYmxlTW9iaWxlIHRvIHRydWUgdG8gYWx3YXlzIHVzZSB0aGUgbm9uLW5hdGl2ZSBwaWNrZXIuXG4gICAgICogQnkgZGVmYXVsdCwgRmxhdHBpY2tyIHV0aWxpemVzIG5hdGl2ZSBkYXRldGltZSB3aWRnZXRzIHVubGVzcyBjZXJ0YWluIG9wdGlvbnMgKGUuZy4gZGlzYWJsZSkgYXJlIHVzZWQuXG4gICAgICovXG4gICAgZGlzYWJsZU1vYmlsZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZWUgPGEgaHJlZj1cImh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci9leGFtcGxlcy8jZGlzYWJsaW5nLWFsbC1kYXRlcy1leGNlcHQtc2VsZWN0LWZld1wiPmVuYWJsaW5nIGRhdGVzPC9hPi5cbiAgICAgKi9cbiAgICBlbmFibGU6IERpc2FibGVFbmFibGVEYXRlW107XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aW1lIHBpY2tlci5cbiAgICAgKi9cbiAgICBlbmFibGVUaW1lOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgc2Vjb25kcyBpbiB0aGUgdGltZSBwaWNrZXIuXG4gICAgICovXG4gICAgZW5hYmxlU2Vjb25kczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdXNpbmcgYSBjdXN0b20gZGF0ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGJ1aWx0LWluIGhhbmRsaW5nIGZvciBkYXRlIGZvcm1hdHMgdXNpbmcgZGF0ZUZvcm1hdCwgYWx0Rm9ybWF0LCBldGMuXG4gICAgICovXG4gICAgZm9ybWF0RGF0ZT86ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQWRqdXN0cyB0aGUgc3RlcCBmb3IgdGhlIGhvdXIgaW5wdXQgKGluY2wuIHNjcm9sbGluZykuXG4gICAgICovXG4gICAgaG91ckluY3JlbWVudDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIHRoZSBjYWxlbmRhciBpbmxpbmUuXG4gICAgICovXG4gICAgaW5saW5lOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGRhdGUgdGhhdCBhIHVzZXIgY2FuIHBpY2sgdG8gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgbWF4RGF0ZTogc3RyaW5nIHwgRGF0ZTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBkYXRlIHRoYXQgYSB1c2VyIGNhbiBzdGFydCBwaWNraW5nIGZyb20gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgbWluRGF0ZTogc3RyaW5nIHwgRGF0ZTtcbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBzdGVwIGZvciB0aGUgbWludXRlIGlucHV0IChpbmNsLiBzY3JvbGxpbmcpLlxuICAgICAqL1xuICAgIG1pbnV0ZUluY3JlbWVudDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIHNpbmdsZSBkYXRlLCBtdWx0aXBsZSBkYXRlcyBvciBhIGRhdGUgcmFuZ2UuXG4gICAgICovXG4gICAgbW9kZTogJ3NpbmdsZScgfCAnbXVsdGlwbGUnIHwgJ3JhbmdlJztcbiAgICAvKipcbiAgICAgKiBIVE1MIGZvciB0aGUgYXJyb3cgaWNvbiwgdXNlZCB0byBzd2l0Y2ggbW9udGhzLlxuICAgICAqL1xuICAgIG5leHRBcnJvdzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBkYXkgc2VsZWN0aW9uIGluIGNhbGVuZGFyLiBVc2UgaXQgYWxvbmcgd2l0aCBgZW5hYmxlVGltZWAgdG8gY3JlYXRlIGEgdGltZSBwaWNrZXIuXG4gICAgICovXG4gICAgbm9DYWxlbmRhcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGV4cGVjdHMgYSBkYXRlIHN0cmluZyBhbmQgbXVzdCByZXR1cm4gYSBEYXRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwYXJzZURhdGU6IChzdHI6IHN0cmluZykgPT4gRGF0ZTtcbiAgICAvKipcbiAgICAgKiBIVE1MIGZvciB0aGUgbGVmdCBhcnJvdyBpY29uLlxuICAgICAqL1xuICAgIHByZXZBcnJvdzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG1vbnRoIHVzaW5nIHRoZSBzaG9ydGhhbmQgdmVyc2lvbiAoaWUsIFNlcCBpbnN0ZWFkIG9mIFNlcHRlbWJlcikuXG4gICAgICovXG4gICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBjYWxlbmRhciBpbnNpZGUgdGhlIHdyYXBwZXIgYW5kIG5leHQgdG8gdGhlIGlucHV0IGVsZW1lbnQuIChMZWF2ZSBgZmFsc2VgIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZykuXG4gICAgICovXG4gICAgc3RhdGljOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIHRpbWUgcGlja2VyIGluIDI0IGhvdXIgbW9kZSB3aXRob3V0IEFNL1BNIHNlbGVjdGlvbiB3aGVuIGVuYWJsZWQuXG4gICAgICovXG4gICAgdGltZTI0aHI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBkaXNwbGF5IG9mIHdlZWsgbnVtYmVycyBpbiBjYWxlbmRhci5cbiAgICAgKi9cbiAgICB3ZWVrTnVtYmVyczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBZb3UgbWF5IG92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSB3ZWVrIG51bWJlcnMgZnJvbSBhIERhdGUgYnkgc3VwcGx5aW5nIGEgZ2V0V2VlayBmdW5jdGlvbi5cbiAgICAgKiBJdCB0YWtlcyBpbiBhIGRhdGUgYXMgYSBwYXJhbWV0ZXIgYW5kIHNob3VsZCByZXR1cm4gYSBjb3JyZXNwb25kaW5nIHN0cmluZyB0aGF0IHlvdSB3YW50IHRvIGFwcGVhciBsZWZ0IG9mIGV2ZXJ5IHdlZWsuXG4gICAgICovXG4gICAgZ2V0V2VlazogKGRhdGU6IERhdGUpID0+IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDdXN0b20gZWxlbWVudHMgYW5kIGlucHV0IGdyb3Vwcy5cbiAgICAgKi9cbiAgICB3cmFwOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBsdWdpbiBpbnN0YW5jZXMgdG8gdXNlLlxuICAgICAqL1xuICAgIHBsdWdpbnM6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbGUgb2JqZWN0IG9yIHN0cmluZyB0byB1c2UgZm9yIHRoZSBsb2NhbGUuXG4gICAgICovXG4gICAgbG9jYWxlOiBvYmplY3QgfCBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQXV0byBjb252ZXJ0IHRoZSBuZ01vZGVsIHZhbHVlIGZyb20gYSBzdHJpbmcgdG8gYSBkYXRlIC8gYXJyYXkgb2YgZGF0ZXMgLyBmcm9tIC0gdG8gZGF0ZSBvYmplY3QgZGVwZW5kaW5nIG9uIHRoZSBgbW9kZWBcbiAgICAgKi9cbiAgICBjb252ZXJ0TW9kZWxWYWx1ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCBvbmNlIHRoZSBjYWxlbmRhciBpcyBpbiBhIHJlYWR5IHN0YXRlXG4gICAgICovXG4gICAgZmxhdHBpY2tyUmVhZHk6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBkYXRlLCBvciBjaGFuZ2VzIHRoZSB0aW1lIG9uIGEgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBmbGF0cGlja3JDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBpcyB1cGRhdGVkIHdpdGggYSBuZXcgZGF0ZSBzdHJpbmcuXG4gICAgICovXG4gICAgZmxhdHBpY2tyVmFsdWVVcGRhdGU6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYWxlbmRhciBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgZmxhdHBpY2tyT3BlbjogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbGVuZGFyIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBmbGF0cGlja3JDbG9zZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vbnRoIGlzIGNoYW5nZWQsIGVpdGhlciBieSB0aGUgdXNlciBvciBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGZsYXRwaWNrck1vbnRoQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgeWVhciBpcyBjaGFuZ2VkLCBlaXRoZXIgYnkgdGhlIHVzZXIgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBmbGF0cGlja3JZZWFyQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogVGFrZSBmdWxsIGNvbnRyb2wgb2YgZXZlcnkgZGF0ZSBjZWxsIHdpdGggdGhpcyBvdXRwdXRcbiAgICAgKi9cbiAgICBmbGF0cGlja3JEYXlDcmVhdGU6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JEYXlDcmVhdGVPdXRwdXRPcHRpb25zPjtcbiAgICBwcml2YXRlIGluc3RhbmNlO1xuICAgIHByaXZhdGUgaXNEaXNhYmxlZDtcbiAgICBwcml2YXRlIGluaXRpYWxWYWx1ZTtcbiAgICBvbkNoYW5nZUZuOiAodmFsdWU6IGFueSkgPT4gdm9pZDtcbiAgICBvblRvdWNoZWRGbjogKCkgPT4gdm9pZDtcbiAgICBjb25zdHJ1Y3RvcihlbG06IEVsZW1lbnRSZWYsIGRlZmF1bHRzOiBGbGF0cGlja3JEZWZhdWx0cywgcmVuZGVyZXI6IFJlbmRlcmVyMik7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkO1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgaW5wdXRDaGFuZ2VkKCk6IHZvaWQ7XG59XG4iXX0=